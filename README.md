该文档包含了数据结构实验四个实验的代码，希望对学弟学妹有帮助

如有问题请联系by wechat:lkx536

实验报告请勿直接复制粘贴

实验编码要求汇总：

![image](https://github.com/user-attachments/assets/23807a02-6424-447b-b80b-3f8e703accbe)


实验一 表达式求值

一 实验目的

设计程序以实验表达式的求值运算，支持‘+’‘-’‘*’‘/’‘^’运算以及‘（’‘）’优先级运算。

二 实验要求

输入：通过命令行参数输入一个数学表达式。

输出：（1）表达式正确的情况下输出结果；
     （2）命令行参数不正确输出字符串ERROR_01 ；
     （3）表达式存在格式错误输出字符串 ERROR_02 ；
     （4）表达式在计算过程中出现逻辑错误输出字符串
      ERROR_03。
      
三 设计思路
	整体上，笔者设计程序利用栈这一数据结构来实现对逆波兰表达式的解析和计算，实现了运算符优先级和结合律等数学规则。
 
（1）宏定义：
程序开始部分使用宏定义来设置一些常量，如`OK`、`ERROR`、栈的初始大小`STACK_INIT_SIZE`和增量`STACKINCREMENT`，以及错误类型`ERROR_01`、`ERROR_02`、`ERROR_03`等。这些宏定义有助于提高代码的可读性和可维护性。

（2）数据结构定义：
程序定义了两个栈结构`SqStack`和`SqStack1`，分别用于存储操作符和操作数。每个栈结构包含一个指向栈底的指针`base`、一个指向栈顶的指针`top`和一个表示栈大小的整数`stacksize`。

（3）栈操作函数：
程序实现了几个基本的栈操作函数，如`InitStack`和`InitStack1`用于初始化栈，`IsEmpty`用于判断栈是否为空，`Push`和`Push1`用于将元素压入栈，`GetTop`和`GetTop1`用于获取栈顶元素，`Pop`和`Pop1`用于从栈中弹出元素。

（4）状态判断函数：
`IsInOP`用于判断一个字符是否是操作符，`Stop`用于判断操作符栈是否为空，`IsIllegial`用于检查输入的字符串是否合法。

（5）辅助函数：
`power`实现了幂运算，`Change`将字符串形式的数字转换为`double`类型，`Operate`实现了基本的数学运算。

（6）运算符优先级表：
`OPCTR_Prior_Table`是一个二维数组，用于存储不同运算符之间的优先级关系。

（7）主要操作函数：
`OPERATION`是程序的核心函数，它处理命令行参数，使用栈来计算数学表达式的值。它首先检查输入的合法性，然后初始化操作符栈和操作数栈，接着按照运算符优先级和结合律处理输入的表达式，最后返回计算结果。
四 运行结果

五 问题与思考
（1）该程序目前仅支持“（”“）”的运算，可以加增更高级别的优先级计算。需要在优先级判断数组矩阵中增加维数。
（2）内存管理方面，该程序中使用`malloc`和`realloc`进行动态内存分配，并且在使用完动态分配的内存后，使用`free`函数进行释放，以避免内存泄漏。
（3）`IsIllegial`函数用于检查输入的合法性，但只检查了连续两个操作符的情况，并未全面检查表达式的完整与合法性。该部分有待继续完善。
六 程序源代码


                
实验二 基于串的模式匹配

一 实验目的
熟练掌握串的实现，学会使用KMP算法解决字符串模式匹配问题。

二 实验要求

（一）执行方式

输入：通过命令行参数输入原字符串和模式字符串。

输出：（1）命令行参数不正确输出字符串ERROR_01；
     （2）如果查找到模式串，输出关键字在字符串中的位置（计数从1开始）；
     （3）如果未找到模式串则输出-1 。
（二）调试手段
通过该实验学习新的调试代码手段：

（1）断点F9、单步执行F10、继续执行F5； 

（2）变量查看，鼠标悬停。

三 设计思路

 笔者通过该程序实现了一个字符串搜索算法，具体来说是Knuth-Morris-Pratt（KMP）算法。KMP算法是一种高效的字符串搜索或模式匹配算法，它可以在O(n)时间复杂度内完成对字符串的搜索，其中n是文本字符串的长度。以下是该程序的设计思路：
 
（1）宏定义：

程序开始处使用宏定义来设置一些常量和状态码，如`OK`、`ERROR`、`ERROR_01`等，以及一些特殊标志，如`big`、`change`、`CHANGE`、`equal`、`small`等

（2）字符串结构体：

定义了一个`String`结构体，用于存储字符串。结构体中包含一个字符指针`base`指向字符串数组，以及一个整数`CurLen`表示字符串的当前长度。

（3）辅助函数：

`max`：取两个数中较大的一个； `STRCOPY`：复制字符串，将一个字符串复制到`String`结构体中； `Strassign`：分配内存并复制字符串到`String`结构体；`StrCompare`：比较两个`String`结构体的字符串，返回`big`、`small`或`equal`；`StrClear`：清空一个`String`结构体，释放内存并重置长度。

（4）KMP算法相关函数：

`get_next`：计算部分匹配表，这是KMP算法的核心之一，用于在模式串中查找尽可能长的前缀也是后缀的字符串；`Index_KPM`：实现KMP搜索算法，搜索模式串`Target`在目标串`Station`中的第一次出现。

（5）主函数`main`：

程序的入口点，分配结果数组，调用`final_Index_Package`进行搜索，然后调用`Ans`输出结果，最后释放结果数组。

（6）内存管理：

程序中使用`malloc`进行动态内存分配，相应的，也有`free`函数调用来释放内存，避免内存泄漏。

（7）错误处理：

程序通过返回状态码来处理错误情况，如内存分配失败、命令行参数错误等。

四 运行结果

五 问题与思考

（1）内存管理：

通过本实验，笔者对动态内存分配和释放的方法以及如何避免内存泄漏等问题有了更深入的认知。

（2）模块化设计：

本实验中，笔者将程序分成多个功能模块，使得代码结构清晰，易于维护和扩展，学生可以学习如何进行模块化设计，提高代码的可读性和可维护性。

（3）调试手段：

本次实验中，笔者学习了新的调试代码手段：首先设置断点，其次启动调试模式， 接着运行程序，最后便可以观察变量和执行过程。

六 程序源代码



实验三 基于哈夫曼树的编码译码
一 实验目的
掌握二叉树的生成、遍历等操作，及哈夫曼编码/译码的原理。
二 实验要求
（一）执行方式
输入：通过命令行参数输入字符串(长度>=20)和码字。
输出：（1）命令行参数不正确输出ERROR_01; 
     （2）编码失败输出ERROR_02; 
     （3）译码失败输出ERROR_03;
     （4）在同一行中输出编码结果和译码结果，中间使用空格隔开。
（二）调试手段
掌握分段调试的方法
三 设计思路
整体上，笔者通过该代码实现了赫夫曼编码和解码的功能，采用了清晰的函数结构和数据结构设计，使得代码易于理解和扩展。
（1）Select 函数：
该函数用于在 HT 数组中选择权值最小的两个节点，并将它们的下标存储在 s1 和 s2 中。这个函数是构建赫夫曼树的关键步骤之一。
（2）HuffmanCoding 函数：
该函数实现了赫夫曼编码的算法。首先根据输入的字符权值构建赫夫曼树，然后通过遍历赫夫曼树的方式得到每个字符的赫夫曼编码，并存储在 HC 数组中。
（3）code 函数：
该函数用于根据构建好的赫夫曼编码表 HC 对输入的字符串进行编码。它根据输入字符串的每个字符，找到对应的赫夫曼编码，并将它们连接起来，最终返回编码后的字符串。
（4）decode 函数：
该函数用于对赫夫曼编码进行解码，将编码后的字符串还原为原始的字符序列。它通过遍历赫夫曼树的方式，根据编码中的 '0' 和 '1' 来进行解码，最终返回解码后的字符串。
四 运行结果

五 问题与思考
（1）算法的优化与复杂度分析：
代码中的算法可能存在优化的空间，比如可以尝试其他的遍历方式或者使用其他的数据结构来实现相同的功能。评估算法的时间复杂度和空间复杂度可以帮助我们更好地理解算法的性能特点，从而进行针对性的优化。
（2）内存管理和错误处理：
在代码中进行大量的内存分配和释放操作是为了避免内存泄漏，确保程序运行的稳定性和效率。错误处理是必需的，它确保了程序在面对异常情况时能够给出适当的提示或采取相应的措施，防止程序崩溃或产生不可预期的结果。
（3）数据结构的选择： 
结构体被选择来表示赫夫曼树的节点，因为它可以将相关的数据字段组织在一起，方便操作。必需的字段包括节点数据、权重、父节点、左孩子和右孩子。
六 程序源代码




实验四 无向图最短路径搜索
一 实验
熟练掌握图的操作，掌握 Dijkstra 算法的原理。
二 实验要求
输入：通过命令行参数输入起点和终点的位置名称。
输出：（1）命令行参数不正确输出ERROR_01; 
     （2）获取最短路径失败时输出ERROR_02; 
     （3）获取最短路径成功时输出路径长度。
三 设计思路
该代码的设计思路可以分为以下几个步骤：
（1）定义图的数据结构：
使用结构体 Graph 表示图，包括顶点数目、边数目和邻接矩阵。使用邻接矩阵表示顶点之间的连接关系。
（2）初始化图：
定义 InitMap 函数初始化图的顶点和边。初始化顶点和边的数量，以及邻接矩阵的初始值。
（3）定义最短路径相关数据结构：
定义 ShortPathList 结构体，包括每个顶点到起点的最短路径长度和访问状态。定义路径矩阵 PathMatrix，用于记录每个顶点到起点的路径。
（4）初始化最短路径列表和路径矩阵：
使用 InitList 函数初始化最短路径列表，设置所有顶点的访问状态和路径长度。使用 InitPath 函数初始化路径矩阵，将起点到起点的路径设置为起点自身。
（5）更新路径和路径长度：
用 ChangeWeight 函数更新路径长度，如果找到更短的路径，则更新路径矩阵和最短路径列表。根据当前节点到其他节点的路径长度更新最短路径列表和路径矩阵。
（6）寻找最短路径：
使用 FindShort 函数寻找未被访问的最短路径节点，更新最短路径列表和路径矩阵。循环执行直到所有节点都被访问过或无法找到更短的路径。
（7）输出最短路径长度：
在 main 函数中调用 ShortestPath 函数计算最短路径长度，并将结果打印输出。可选地，使用 PrintPath 函数输出具体的最短路径。
（8）错误处理和内存释放：
在 main 函数中对输入参数进行合法性检查，以及对动态分配的内存进行释放，确保程序的健壮性和稳定性。
四 运行结果

五 问题与思考
（1）最短路径算法的选择：
选择合适的最短路径算法，如 Dijkstra 算法、Floyd-Warshall 算法等。对于简单的图结构，Dijkstra 算法通常是一个不错的选择，它可以有效地计算单源最短路径。
（2）算法实现细节：
可以通过分析算法的基本思想，将其转化为具体的代码实现。例如，使用循环遍历顶点来查找未访问的最短路径节点，并根据当前节点到其他节点的路径长度更新最短路径列表和路径矩阵。
（3）内存管理与资源释放：
可以使用合适的内存分配和释放函数，如 malloc 和 free，在代码中及时释放不再需要的内存空间，确保程序的稳定性和效率。
六 程序源代码

